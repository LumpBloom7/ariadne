/***************************************************************************
 *            computability.dox
 *
 *  Copyright  2020  Pieter Collins
 *
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */



/*! \file computability.dox
 *  \brief Documentation on the foundations of computable analysis
 */

namespace Ariadne {

/*!

\page computable_analysis_page %Foundations of Computable Analysis

This page describes the information-theoretic foundations of computable analysis.
For details on how this is implemented in %Ariadne, see the \ref InformationSubModule documentation.

For more detailed information on topological constructions, see the \ref topology_page page.
Also see the \ref logic_page page, the \ref real_numbers_page page.

For more information, see
 - P. Collins, "Computable Analysis with Applications to Dynamic Systems", <i>Mathematical Structures in Computer Science</i> <b>30</b>(2), pp. 173-233, 2020.
.

\section type_two_computability_section Computability on Uncountable Spaces

Computable analysis deals with rigorous computations on the uncountable spaces arising in analysis, topology and geometry.
In order to represent elements of uncountable spaces, we need sequences or <em>streams</em> of data, instead of finite lists or words.
Computations are performed by ordinary Turing machines, but run forever, reading data from the input streams and writing to the output streams.
In order to be useful, it must be possible to obtain meaningful information from a finite prefix of the output data, just as from a prefix of the decimal expansion \f$\pi=3.14159\cdots\f$ we know \f$\pi\in[3.14159\!:\!3.14160]\f$.

Formally, we fix a finite <em>alphabet</em> of symbols \f$\Sigma\f$, such as the binary alphabet \f$\{0,1\}\f$, and consider computation on \f$\Sigma^\omega\f$. (One can also use countable alphabets, such as \f$\N\f$, which gives rise to the same computability theory, but a less realistic theory of computational complexity.)
A natural topology on \f$\Sigma^\omega\f$ is generated by <em>cylinder sets</em> of the form \f$W=\{ p\in\Sigma^\omega \mid p|_{|w|}=w \}\f$ for \f$w\in\Sigma^*\f$.
A Turing machine \f$\mathcal{M}\f$ computes a partial function \f$\eta_\mathcal{M}:\Sigma^\omega\pfto\Sigma^\omega\f$ which is continuous and is defined on a \f$G_\delta\f$-subset of \f$\Sigma^\omega\f$ (i.e. on a countable intersection of open sets).
We say a continuous partial function \f$\eta:\Sigma^\omega\pfto\Sigma^\omega\f$ is <em>machine-computable</em> there is a Turing machine \f$\mathcal{M}\f$ for which \f$\eta=\eta_\mathcal{M}\f$.

\subsubsection representations Representations

A <em>representation</em> of a set \f$X\f$ is a partial surjective functon \f$\delta:\Sigma^\omega\psfto X\f$.
An element \f$p\in\Sigma^\omega\f$ such that \f$\delta(p)=x\f$ is a <em>\f$\delta\f$-name</em> of \f$x\f$.

The representation \f$\delta\f$ induces the natural <em>quotient topology</em> on \f$X\f$, with \f$U\f$ open in \f$X\f$ if, and only if, \f$\delta^{-1}(U)\f$ is open in \f$\Sigma^\omega\f$.
If \f$X\f$ already has a topology \f$\tau\f$, we say \f$\delta\f$ is a <em>quotient representation</em> of \f$(X,\tau)\f$ if \f$\tau\f$ is the induced quotient topology of \f$\delta\f$.

A representation is <em>admissible</em> if it is a "weakest" representation inducing the same topology.
i.e. if whenever \f$\phi:\Sigma^\omega\psfto X\f$ is continuous, then there exists continuous \f$\eta:
\Sigma^\omega\pfto\Sigma^\omega\f$ such that \f$\phi=\delta\circ\eta\f$.

By a result of Schr√∂der (2002), a space has an admissible quotient representation if, and only if, it is a quotient of a countably-based space.

The purpose of a representation is to transfer computability notions from \f$\Sigma^\omega\f$ to \f$X\f$.
Given representations \f$\delta_X\f$ of \f$X\f$ and \f$\delta_Y\f$ of \f$Y\f$, a function \f$f:X\to Y\f$ is <em>\f$(\delta_X;\delta_Y)\f$-computable</em> if there is a machine-computable function \f$\eta:\Sigma^\omega\pfto\Sigma^\omega\f$ such that \f$f\circ\delta_X = \delta_Y\circ\eta|_{\dom(\delta_X)}\f$.
The notion extends to functions \f$f:X_1\times\cdots\times X_n\to Y\f$ in a natural way.
An element \f$y\f$ of \f$Y\f$ is \f$\delta_Y\f$-computable if there is a machine with no inputs which outputs a name of \f$y\f$.

A representation \f$\delta'\f$ of \f$X\f$ is <em>weaker</em> than \f$\delta\f$ if there is a machine-computable function \f$\eta:\Sigma^\omega\pfto\Sigma^\omega\f$ such that \f$\delta'=\delta\circ\sigma\f$.
In other words, given a \f$\delta\f$-name \f$p\f$ of \f$x\f$, we can compute a \f$\delta'\f$-name \f$p'\f$.
Representations are <em>equivalent</em> if each is weaker than the other.

For most spaces encountered in practise, there is precisely one natural representation, up to equivalence.
Rather than explicitly mention this every time, we define a <em>type</em> \f$\mathbb{X}\f$ as a pair \f$(X,[\delta])\f$ where \f$X\f$ is a set/space, and \f$[\delta]\f$ is an equivalence class of representations of \f$X\f$.
For example, the real numbers have a unique equivalence class of representations under which arithmetic and comparisons are computable. (See the \ref real_numbers page for more details.)

\subsubsection universal_turing_machine Universal type-two Turing machine

There exists a representation \f$\sigma\f$ of continuous \f$\Sigma^\omega\pfto\Sigma^\omega\f$, and a corresponding <em>universal</em> type-two Turing machine \f$\mathcal{U}\f$ computing a function \f$\epsilon:\Sigma^\omega\times\Sigma^\omega\to\Sigma^\omega\f$ with the following properties:
 - If \f$\eta:\Sigma^\omega\pfto\Sigma^\omega\f$ is a machine-computable function, then there is a computable sequence \f$p:\Sigma^\omega\f$ such that \f$\sigma(p)=\eta\f$.
 - If \f$p\in\dom(\sigma)\f$ and \f$q\in\dom(\sigma(p))\f$, then \f$(p,q)\in\dom(\epsilon)\f$, and \f$\epsilon(p,q)=[\sigma(p)](q)\f$.
.
In other words, \f$p:\Sigma^\omega\f$ encodes the information needed to specify a continuous function \f$\eta\f$ acting on sequences.
If \f$\eta\f$ is a computable function, then \f$p\f$ is a computable sequence.
The information encoded by \f$p\f$ can be read by the Turing machine \f$\mathcal{U}\f$ and used to compute the image of the input \f$q\f$ under the encoded function \f$\eta\f$.

\subsection categorical_constructions Standard Type Constructions

There are a number of standard ways of constructing new types from old. In particular
 - Given types \f$\X_0,\X_1,\X_2,\ldots\f$, the finite products \f$\X_0\times\cdots\times\X_{n-1}\f$ and countable products \f$\prod_{n=0}^{\infty}X_n\f$.
 - Given type \f$\X,\Y\f$, the function type \f$\X\to\Y\f$, also denoted \f$\Y^\X\f$.
 - Given type \f$\X\f$ and a subset \f$S\f$, the <em>subtype</em> formed by restricting the representation of \f$X\f$ to \f$S\f$.
.




\section effective_validated_information Effective and Validated Information

Given a type \f$\X=(X,[\delta])\f$, given a word \f$w\f$ we can consider the set \f$\delta(w\Sigma^\omega)=\{x\in X\mid \exists p\in\Sigma^\omega, \delta(p)=x \wedge p|_{|w|}=w\}\f$.
In other words, the set of all points with a name which has a prefix \f$w\f$.

In general, these sets are neither open nor closed nor compact.
However, for many representations, these sets are either open neighbourhoods, or compact sets.

In particular, we have a countable collection \f$\widehat{X}\f$ of subsets of \f$X\f$.

We call the information provided by a full name of an element \f$X\f$ <em>effective</em> information, and information provided by a finite prefix of a full name <em>validated</em> (or <em>verified</em>).

Although effective information is stronger than validated information, there is no canonical conversion from effective to validated information, since each prefix of a name provides validated information.
Instead, for every integer \f$n\f$, we can extract the validated information provided by the word \f$p|_n=p_0p_1\cdots p_{n-1}\f$.

We say a Turing machine \f$\mathcal{M}\f$ computing a function \f$\eta:\Sigma^\omega\to\Sigma^\omega\f$ is <em>proper</em> if it eventually reads every symbol for any valid input.
Examples of non-proper Turing machines include those computing functions with constant pieces e.g. \f$f(x)=\max(0,x)\f$.
However, any non-proper machine can be converted to a proper machine computing the same function by unnecessarily reading extra symbols of the input stream.


Given representation \f$\delta_{X},\delta_{Y}\f$ of \f$X,Y\f$, a computable operator \f$f:\X\to\Y\f$, and a Turing machine \f$\mathcal{M}\f$ computing \f$\eta_\mathcal{M}:\Sigma^\omega\to\Sigma^\omega\f$, we can consider computing applying \f$\mathcal{M}\f$ to the partial information provided by a word \f$w\in\Sigma^*\f$ which is a prefix of \f$p\in\dom(\eta_\mathcal{M})\f$.
As long as \f$\mathcal{M}\f$ is proper (i.e. needs to access the complete sequence \f$p\f$ to compute \f$\eta_\mathcal{M}(p)\f$), when applied to \f$w\f$, the computation at some point needs to access the input beyond the information provided by \f$w\f$.
At this point, we terminate the computation, and output the word currently on the output stream.
In this way, any proper Turing machine computing \f$\eta:\Sigma^\omega\pfto\Sigma^\omega\f$ induces a natural operation \f$\Sigma^*\to\Sigma^*\f$.
Interpreting the computation on \f$X,Y\f$, we obtain a function \f$\hatX\to\hatY\f$.

Similarly, given representations \f$\delta_{X_1},\delta_{X_2},\delta_{Y}\f$ of \f$X_1,X_2,Y\f$, a computable operator \f$f:\X_1\times \X_2\to \Y\f$, and a Turing machine \f$\mathcal{M}\f$ computing \f$\eta_\mathcal{M}:\Sigma^\omega\times\Sigma^\omega\to\Sigma^\omega\f$, we can consider computing on a finite prefix \f$w_1\f$ of the first input \f$p_1\f$, resulting in a machine-computable function \f$\Sigma^*\times\Sigma^\omega\to\Sigma^*\f$, inducing a function \f$\hatX_1\times X_2 \to\hatY\f$.
In other words, a proper binary operator can be applied to an effective and a validated argument.



\subsubsection effective_to_validated_conversion Effective to validated conversion

Note, however, that there is no general effective-to-validated conversion, even for functions.
Even though an effective function can be applied to a validated argument, and this encodes all the information about the function, an algorithm to compute information about a function by evaluating on different arguments, still returns effective information, and typically will not terminate.
(An example could be computing the definite integral; one can compute \f$\int_0^1f(x)dx\f$ arbitrarily accurately given the function \f$\widehat{\R}\to\widehat{\R}\f$ induced by \f$f\f$.)










*/

} // namespace Ariadne
