/***************************************************************************
 *            python_modules_tutorial.dox
 *
 *  Copyright  2009-20  Pieter Collins
 *
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/*!
 * \file python_modules_tutorial.dox
 * \brief Documentation for the tutorial on Ariadne's Python modules
 */

namespace Ariadne {

/*!

\page python_modules_tutorial_page Python Modules Tutorial

On this page, we explain how to use %Ariadne's internal function calculus via the Python interface. First, a brief overview of the numerical types and linear algebra operations are given in the \ref python_modules_tutorial_numerical and \ref python_modules_tutorial_linear_algebra sections. A guide to the nonlinear functions available is given in \ref python_modules_tutorial_functional_calculus. Finally, a guide to the numerical Taylor calculus is given in \ref python_modules_tutorial_taylor_calculus.

The full code of the tutorial is given in \ref python/tutorials/modules_tutorial.py

\dontinclude python/tutorials/modules_tutorial.py



\section python_modules_tutorial_introspection The Ariadne module.

First, import the %Ariadne module. For ease-of-use, the <tt>from</tt> version of <tt>import</tt> is recommended:
\skipline import
To see all the classes and functions available in %Ariadne, type:
\skipline dir

\section python_modules_tutorial_numerical Numerical Types

%Ariadne supports several basic numerical types, including core \ref Integer, \ref Dyadic, \ref Decimal, \ref Rational and \ref Real classes, which store numbers exactly. These number types are good for problem specification, but may be inefficient for actual numerical computations.

The \ref Integer class supports integers of arbitrary size.
\skipline Integer

The \ref Dyadic class supports numbers of the form \f$p/2^q\f$ where \f$p\f$ and \f$q\f$ are integers.
These include all numbers of binary floating-point types and are useful as computational intermediates.
\skip Dyadic
\until two

The \ref Decimal class supports exact representation of decimal numbers.
Numbers can be constructed from floating-point values up to around 9 decimal places; for more accuracy a string literal must be used:
\skipline Decimal
\skipline Decimal
\skipline Decimal

The \ref Rational class supports exact representation of rational numbers.
\skipline Rational
\skipline Rational
\skipline Rational

The \ref Real number class supports arbitrary formulae.
\skipline Real
\skipline Real

Computations in %Ariadne are usually most efficiently performed using floating-point number types. %Ariadne internally supports the \ref FloatDP and \ref FloatMP types, which are respectively based on builtin IEEE double-precision floating-point numbers, and multiple-precision floating-point numbers from the MPFR library.

Since Python's builtin <tt>float</tt> class uses rounded arithmetic, such numbers may not be an exact representation of a value, leading to unsafe computation. If a Python <tt>float</tt> is indeed an exact value, (e.g. 1.375 is an exact double-precision floating-point number), this must first be converted to an %Ariadne \ref ExactDouble class:
\skipline ExactDouble
\skipline exact
Numbers which are not exactly representable in double-precision should be converted to the \ref Decimal class instead.

%Ariadne uses C++/Python's built-in floating-point types to provide a double-precision floating-point number class \ref FloatDP, and the MPFR library to provide a multiple-precision floating-point type \ref FloatMP. Each type has a corresponding precision:
\skipline DoublePrecision
\skipline double_precision
\skipline MultiplePrecision
Floating-point numbers can be constructed from integers and dyadic numbers by supplying the precision:
\skipline FloatDP
\skipline FloatMP

Raw floating-point numbers only support rounded arithmetic, so are best avoided in user code. Instead, they can be used in safe correctly-rounded generic types  \ref Value "Value<F>", \ref Ball "Ball<F,FE>", \ref Bounds "Bounds<F>", \ref UpperBound "UpperBound<F>", \ref LowerBound "LowerBound<F>" and \ref Approximation "Approximation<F>". For example, the %Bounds classes support outward-rounded interval arithmetic
\skipline =FloatDPBounds
\skipline =FloatDPBounds
\skipline =FloatMPBounds
\skipline =FloatMPBounds
\skipline =FloatMPBounds
and the %Approximation classes support approximate arithmetic.
\skipline =FloatDPApproximation
\skipline =FloatMPApproximation
\skipline =FloatMPApproximation



\section python_modules_tutorial_linear_algebra Linear Algebra

%Ariadne supports linear algebra operations based on Vector and Matrix classes. In the C++ library, these types are parameterised by the scalar type (e.g. %Rational, %FloatDPBounds).

%Vector and matrix classes can be constructed using Python lists.
\skipline Vector
\skipline RationalMatrix
\skipline Matrix

As well as matrix and vector arithmetic, %Ariadne provides a \c solve routine for solving systems of linear equations:
\skipline solve

\subsection python_modules_tutorial_linear_algebra_slicing Slicing (Future addition)

In the future, it will be possible to create \c VectorSlice and \c MatrixSlice objects using Python's slicing operatior. As in Matlab and other C++ libraries, and unlike Python sequences, these operations return a "view" into the structure, and not a copy, so can be used for in-place modification.

The semantics of this operator have not been determined, since Python has different conventions from C++ libraries such as the STL \c valarray class, glas and uBlas \c vector classes and Matlab classes. For example, if \c v is the vector <c>[0,1,2,3,4,5,6,7,8,9]</c>, then different possibilities are

 - Python: <c> v[start:finish:stride] </c>  e.g. <c>v[1:6:2]</c> = <c>v[1:7:2]</c> = <c>[1,3,5]</c>;

 - C++ STL \c valarray : <c> v[slice(start,size,stride)]</c> e.g.  <c> v[slice(1,3,2)]</c>\c  = <c>[3,5,7]</c>;

 - C++ uBlas: \c <c> project(v,slice(start,stride,size)) </c>  e.g.  <c>project(v,slice(1,2,3))</c> = <c>[1,3,5]</c>;

 - C++ glas: \c <c> slice(start,finish,stride)) </c>  e.g.  <c>v[slice(1,6,2)])</c> = <c>v[slice(1,7,2)])</c> = <c>[1,3,5]</c>;

 - Matlab: <c> v(first:stride:last) </c> with one-based indexing; e.g. <c>v(2:2:6)</c> = <c>v(2:2;7)</c> = <c>[1,3,5]</c>;

The main design decision is whether to use a single "Ariadne" slicing semantics which is used for any and all interfaces, or whether to use the natural semantics for the given environment. For the C++ API, we could provide STL \c valarray semantics <c> v[slice(start,size,stride=1)] </c> and Python semantics <c> v[range(start,finish,stride=1)] </c>.

\sa  \ref LinearAlgebraModule, Vector, Matrix



\section python_modules_tutorial_function Functions

%Ariadne supports nonlinear functions by means of abstract classes, including \ref EffectiveScalarMultivariateFunction for scalar functions \f$f:\R^m\rightarrow\R\f$
\skipline EffectiveScalarMultivariateFunction
\skipline sf=
\skipline =sf(
\skipline =sf(
and the \ref EffectiveVectorMultivariateFunction for functions \f$f:\R^m\rightarrow\R^n\f$.
\skipline EffectiveVectorMultivariateFunction
\skipline vf=
\skipline =vf(
\skipline =evaluate(vf,
and functions of a scalar argument \ref EffectiveScalarUnivariateFunction for functions \f$f:\R\rightarrow\R\f$, \ref EffectiveVectorUnivariateFunction for \f$f:\R\rightarrow\R^n\f$.

These functions can be differentiated with respect to their coordinates.
\skipline =derivative(

The \ref Polynomial "Polynomial<X>" class provides concrete implementations of the function calculus. For example, \ref FloatDPApproximationMultivariatePolynomial class defines a polynomial in multiple variables with coefficients of type \ref FloatDPApproximation.
A polynomial can be created by using the <tt>coordinate(n,j)</tt> static method, which creates the polynomial \f$p(x)=x_j\f$ for \f$x\in\R^n\f$:
\skipline p0=FloatDPApproximationMultivariatePolynomial
\skipline p1=FloatDPApproximationMultivariatePolynomial
The standard arithmetical operations are available for polynomial expressions:
\skipline q=



\section python_modules_tutorial_taylor_functional_calculus Taylor Function Calculus

The generic function interfaces cannot generally be directly manipulated. Instead, they can be converted to numerical \ref ValidatedScalarMultivariateTaylorFunctionModelDP and \ref ValidatedVectorMultivariateTaylorFunctionModelDP types which can then be worked with.

The core type is a \ref ScalarMultivariateTaylorFunctionModel "ScalarMultivariateTaylorFunctionModel<P,F>", which is a polynomial \a p precomposed by a scaling \a s<sup>-1</sup> of a function \a f on a box \a D in Euclidean space with uniform error \a e:
\f$ f(x) = p(s^{-1}(x))\pm e \text{ for } x\in D . \f$

To construct a Taylor function model, we need to give the domain and a "sweeper" which controls the accuracy.
\skipline BoxDomainType(
\skipline ThresholdSweeperDP(

Constant and coordinated functions can easily be created
\skipline ValidatedScalarMultivariateTaylorFunctionModelDP.constant(
\skipline ValidatedScalarMultivariateTaylorFunctionModelDP.coordinate(
and a general function can be converted to a Taylor function model
\skipline EffectiveScalarMultivariateFunction.coordinate(
\skipline ValidatedScalarMultivariateTaylorFunctionModelDP(

We can extract the domain of the functions, and over-approximations to the codomain/range
\skipline domain(
\skipline codomain(
\skipline range(

Taylor function models support arithmetic
\skipline tx+ty
and mixed arithmetic with numerical types
\skipline tx+c
\skipline c+tx
They also support lattice operations,
\skipline min
standard named arithmetical operations,
\skipline neg
\skipline rec
\skipline sqr
\skipline pow
and roots, exponentials, logarithms and trigonometric functions
\skipline sqrt
\skipline exp
\skipline sin
In-place operations are also provided
\skipline +=
\skipline +=


We can compute antiderivatives (indefinite integrals) with respect to the coordinates
\skipline =antiderivative(
specifying an optional base-point
\skipline =antiderivative(

For higher accuracy, the approximation can be restricted to a subdomain
\skipline =restriction(

Standard function operations are provided, including direct sum (join) \f$x\mapsto[f(x),g(x)]\f$ and product (combine) \f$[x,y]\mapsto[f(x),g(y)]\f$.
\skipline =join(
\skipline =combine(

Taylor function models can be post-composition by a generic function
\skipline =compose(
\skipline =compose(
or composed with another Taylor function model
\skipline =compose(
\skipline =compose(


Since Taylor function models provide a set of possibilities for the actual function, we can test whether two computations are inconsistent (disjoint) or if one refines another, and compute the common refinement
\skipline =inconsistent(
\skipline =refines(
\skipline =refinement(



\section python_modules_tutorial_solvers Solvers

%Ariadne uses %Solver classes for complicated operations such as solving algebraic or differential equations.

\subsection python_modules_tutorial_algebraic_solvers Solving Algebraic Equations

We can solve parameterised algebraic equations using the operator \c implicit of a \a Solver class.
If \f$f:D_1\times D_2\rightarrow \R^n\f$ with \f$D_2\subset\R^n\f$ then the operator \c implicit(f) attempts to compute a function \f$h:D_1\to\R^n\f$ such that \f$f(x,h(x))=0\f$ for \f$x\in D_m\f$. The function \f$h\f$ must satisfy \f$h(D_1)\subset D_2\f$.

\snippet python/tutorials/modules_tutorial.py Algebraic Solver demonstration


\subsection python_modules_tutorial_differential_equation_solvers Solving Differential Equations

We can solve differential equations using the operator \c flow of the \a Integrator.
If \f$:\R^n\to\R^n\f$, \f$D\subset\R^n\f$ and \f$h>0\f$, then the operator \c flow(f,D,h) computes a function \f$\phi:D\times[0,h]\to\R^n\f$ satisfying \f$\dt{\phi}(x,t)=f(\phi(x,t))\f$ and \f$\phi(x,0)=x\f$.

\snippet python/tutorials/modules_tutorial.py Differential Solver demonstration

*/

} // namespace Ariadne
